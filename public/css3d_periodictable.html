<!DOCTYPE html>
<html>
	<head>
		<title>Kasatria Technologies</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000; 
				margin: 0; 
				overflow: hidden; 
			}

			#info {
				color: #ffffff; 
				font-family: Helvetica, sans-serif;
				position: absolute;
				top: 10px;
				left: 10px;
				z-index: 100;
			}

			a {
				color: #8ff;
			}

			#menu {
				position: absolute;
				bottom: 20px;
				width: 100%;
				text-align: center;
			}

			.element {
				width: 140px;
				height: 200px;
				box-shadow: 0px 0px 20px rgba(0,0,0,0.8);
				border: 3px solid #333;
				font-family: Arial, sans-serif;
				text-align: center;
				cursor: default;
				position: relative;
				overflow: hidden;
				border-radius: 8px;
			}

			.element:hover {
				box-shadow: 0px 0px 30px rgba(255,255,255,0.3);
				border: 3px solid #666;
			}

			.element .countryDiv {
				position: absolute;
				top: 17px;
				left: 8px;
				font-size: 9px;
				color: #ffffff;
				color: rgba(255, 255, 255, 0.7); 
				z-index: 3;
				font-weight: 200;
				padding: 2px 6px;
				border-radius: 3px;
				max-width: 50px;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}

			.element .age-badge {
				position: absolute;
				top: 17px;
				right: 8px;
				font-size: 9px;
				color: #ffffff;
				color: rgba(255, 255, 255, 0.7); 
				z-index: 3;
				font-weight: 200;
				padding: 2px 6px;
				border-radius: 3px;
			}

			.element .photo-container {
				position: absolute;
				top: 35px;
				left: 10px;
				right: 10px;
				height: 110px;
				background: #ffffff;
				border-radius: 1px;
				overflow: hidden;
				z-index: 2;
			}

			.element .photo {
				width: 100%;
				height: 100%;
				object-fit: cover;
				opacity: 1;
			}

			.element .name {
				position: absolute;
				top: 153px;
				left: 10px;
				right: 10px;
				font-size: 11px; 
				font-weight: bold;
				color: rgba(255, 255, 255, 0.7); 
				z-index: 3;
				line-height: 1.2;
				word-wrap: break-word;
			}

			.element .interest {
				position: absolute;
				bottom: 10px;
				left: 10px;
				right: 10px;
				font-size: 9px;
				color: rgba(255,255,255,0.7);
				font-weight: 200;
				z-index: 3;
			}

			button {
				color: rgba(127,255,255,0.75);
				background: transparent;
				outline: 1px solid rgba(127,255,255,0.75);
				border: 0px;
				padding: 5px 10px;
				cursor: pointer;
			}

			button:hover {
				background-color: rgba(0,255,255,0.5);
			}

			button:active {
				color: #000000;
				background-color: rgba(0,255,255,0.75);
			}
		</style>
	</head>
	<body>

    <div id="container"></div>
    <div id="menu">
        <button id="table">TABLE</button>
        <button id="sphere">SPHERE</button>
        <button id="helix">HELIX</button>
        <button id="grid">GRID</button>
        <button id="tetrahedron">TETRAHEDRON</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./libs/three.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

    <script type="module">

        import * as THREE from 'three';
        import TWEEN from './libs/tween.module.js';
        import { TrackballControls } from './libs/TrackballControls.js';
        import { CSS3DRenderer, CSS3DObject } from './libs/CSS3DRenderer.js';
        import { fetchSheetData } from './app.js';

        const SPREADSHEET_ID = '14q2ti-BUJ0-HQMYxiWPUP3hRXYCJUcDoiMSajgiSK0I';
        const API_KEY = 'AIzaSyDaOlmf99IWrZdDcMLEZPAIbrO4DrBvdZM'; 

        let SHEET_DATA = [];

        let camera, scene, renderer;
        let controls;

        const objects = [];
        const targets = { table: [], sphere: [], helix: [], grid: [], tetrahedron: [] };

        // load sheet THEN init 3D
        start();

        async function start() {
            const raw = await fetchSheetData(SPREADSHEET_ID, API_KEY);
            raw.shift(); 
            SHEET_DATA = raw;
            
            console.log('Total rows:', SHEET_DATA.length);
            
            if (SHEET_DATA[0][0] && SHEET_DATA[0][0].includes('__')) {
                const parts = SHEET_DATA[0][0].split('__');
                console.log('Parsed parts:', parts);
            }
            
            init();
            animate();
        }

        function init() {
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 3000;

            scene = new THREE.Scene();

            // table 20x10 
            for (let i = 0; i < SHEET_DATA.length && i < 200; i++) {
                const row = SHEET_DATA[i];
                
                let name, imageUrl, age, country, interest, networth;
                
                if (row.length === 1 && row[0].includes('__')) {
                    // data seperated by __ 
                    const parts = row[0].split('__');
                    name = parts[0] || 'Unknown';
                    imageUrl = parts[1] || '';
                    age = parts[2] || '';
                    country = parts[3] || '';
                    interest = parts[4] || '';
                    networth = parts[5] || '0';
                } else if (row.length >= 6) {
                    // data is in separate columns
                    name = row[0] || 'Unknown';
                    imageUrl = row[1] || '';
                    age = row[2] || '';
                    country = row[3] || '';
                    interest = row[4] || '';
                    networth = row[5] || '0';
                } else {
                    // fallback
                    name = String(row[0] || 'Unknown');
                    imageUrl = '';
                    age = '';
                    country = '';
                    interest = '';
                    networth = '0';
                }

                // calculate position in 20x10 
                const col = (i % 20) + 1;
                const rowNum = Math.floor(i / 20) + 1;

                const element = document.createElement('div');
                element.className = 'element';

                // net worth color
                let worthStr = String(networth).trim().replace(/[$,]/g, "");
                let worth = parseFloat(worthStr);
                
                let borderColor = '#EF3022'; 
				let bgColor = 'rgba(239,48,34,0.6)'; 

				if (!isNaN(worth) && worth > 0) {
					if (worth >= 200000) {
						borderColor = '#3A9F48'; 
						bgColor = 'rgba(58,159,72,0.6)';
					} else if (worth >= 100000) {
						borderColor = '#FDCA35'; 
						bgColor = 'rgba(253,202,53,0.6)';
					}
				}

                element.style.borderColor = borderColor;
                element.style.backgroundColor = bgColor;

                // country
                const countryDiv = document.createElement('div');
                countryDiv.className = 'countryDiv';
                countryDiv.textContent = country || 'N/A';
                element.appendChild(countryDiv);

                // age
                if (age) {
                    const ageBadge = document.createElement('div');
                    ageBadge.className = 'age-badge';
                    ageBadge.textContent = age;
                    element.appendChild(ageBadge);
                }

                // photo container
                const photoContainer = document.createElement('div');
                photoContainer.className = 'photo-container';
                
                if (imageUrl && imageUrl.trim() !== '') {
                    const cleanUrl = imageUrl.trim();
                    if (cleanUrl.startsWith('http')) {
                        const img = document.createElement('img');
                        img.className = 'photo';
                        img.src = cleanUrl;
                        img.onerror = function() {
                            this.style.display = 'none';
                        };
                        photoContainer.appendChild(img);
                    }
                }
                element.appendChild(photoContainer);

                // name
                const nameDiv = document.createElement('div');
                nameDiv.className = 'name';
                nameDiv.textContent = name;
                element.appendChild(nameDiv);

                // interest
                const interestDiv = document.createElement('div');
                interestDiv.className = 'interest';
                interestDiv.textContent = interest || country || '';
                element.appendChild(interestDiv);

                // 3D OBJECT INITIAL RANDOM PLACEMENT
                const objectCSS = new CSS3DObject(element);
                objectCSS.position.x = Math.random() * 4000 - 2000;
                objectCSS.position.y = Math.random() * 4000 - 2000;
                objectCSS.position.z = Math.random() * 4000 - 2000;

                scene.add(objectCSS);
                objects.push(objectCSS);

                // TABLE TARGET - 20x10 GRID
                const obj = new THREE.Object3D();
                obj.position.x = ((col - 1) * 150) - (19 * 150 / 2);
                obj.position.y = -((rowNum - 1) * 210) + (9 * 210 / 2);

                targets.table.push(obj);
            }

            // SPHERE
            const vector = new THREE.Vector3();
            for (let i = 0, l = objects.length; i < l; i++) {
                const phi = Math.acos(-1 + (2 * i) / l);
                const theta = Math.sqrt(l * Math.PI) * phi;

                const object = new THREE.Object3D();
                object.position.setFromSphericalCoords(800, phi, theta);

                vector.copy(object.position).multiplyScalar(2);
                object.lookAt(vector);

                targets.sphere.push(object);
            }

            // DOUBLE HELIX
            for (let i = 0, l = objects.length; i < l; i++) {
                const angle = i * 0.3;
                const height = (i * -15) + 500;

                const radius = (i % 2 === 0) ? 900 : 600;
                const object = new THREE.Object3D();

                object.position.x = Math.cos(angle) * radius;
                object.position.z = Math.sin(angle) * radius;
                object.position.y = height;

                object.lookAt(new THREE.Vector3(
                    object.position.x * 2,
                    object.position.y,
                    object.position.z * 2
                ));

                targets.helix.push(object);
            }

            // 5x4x10 (5 columns, 4 rows, 10 layers)
            for (let i = 0; i < objects.length; i++) {
                const object = new THREE.Object3D();

                const x = i % 5;                        
                const y = Math.floor(i / 5) % 4;        
                const z = Math.floor(i / 20);           

                object.position.x = (x * 400) - 800;    
                object.position.y = -(y * 400) + 600;   
                object.position.z = (z * 1000) - 4500;  

                targets.grid.push(object);
            }
            
            // TETRAHEDRON 
            {
                const radius = 2000; 

                const verts = [
                    new THREE.Vector3( 1,  1,  1),
                    new THREE.Vector3(-1, -1,  1),
                    new THREE.Vector3(-1,  1, -1),
                    new THREE.Vector3( 1, -1, -1)
                ];
                verts.forEach(v => v.normalize().multiplyScalar(radius));

                const faces = [
                    [0, 1, 2],
                    [0, 2, 3],
                    [0, 3, 1],
                    [1, 2, 3]
                ];

                // reset targets for tetrahedron
                targets.tetrahedron = [];

                const total = objects.length;
                const perFaceBase = Math.floor(total / 4);
                const remainder = total % 4;

                for (let f = 0; f < 4; f++) {
                    const faceCount = perFaceBase + (f < remainder ? 1 : 0);
                    if (faceCount === 0) continue;

                    const face = faces[f];
                    const A = verts[face[0]];
                    const B = verts[face[1]];
                    const C = verts[face[2]];

                    // generate points on triangle
                    const picked = generatePointsOnTriangle(A, B, C, faceCount);

                    // compute face normal
                    const AB = B.clone().sub(A);
                    const AC = C.clone().sub(A);
                    let faceNormal = AB.clone().cross(AC).normalize();
                    if (A.clone().normalize().dot(faceNormal) < 0) faceNormal.negate();

                    // create target objects
                    for (let p = 0; p < picked.length; p++) {
                        const pt = picked[p].clone();
                        const obj = new THREE.Object3D();
                        obj.position.copy(pt);

                        // orient to face outward
                        const lookTarget = pt.clone().add(faceNormal);
                        obj.lookAt(lookTarget);

                        targets.tetrahedron.push(obj);
                    }
                }

                // fill in if counts mismatch
                while (targets.tetrahedron.length < total) {
                    const clone = targets.tetrahedron[targets.tetrahedron.length % targets.tetrahedron.length].clone();
                    targets.tetrahedron.push(clone);
                }
            }

            // RENDERER
            renderer = new CSS3DRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // CONTROLS
            controls = new TrackballControls(camera, renderer.domElement);
            controls.minDistance = 500;
            controls.maxDistance = 6000;
            controls.addEventListener('change', render);

            // BUTTON EVENTS
            document.getElementById('table').onclick = () => transform(targets.table, 2000);
            document.getElementById('sphere').onclick = () => transform(targets.sphere, 2000);
            document.getElementById('helix').onclick = () => transform(targets.helix, 2000);
            document.getElementById('grid').onclick = () => transform(targets.grid, 2000);
            document.getElementById('tetrahedron').onclick = () => transform(targets.tetrahedron, 2000);


            transform(targets.table, 2000);

            window.addEventListener('resize', onWindowResize);
        }

        function transform(targets, duration) {
            TWEEN.removeAll();

            for (let i = 0; i < objects.length; i++) {
                const object = objects[i];
                const target = targets[i];

                new TWEEN.Tween(object.position)
                    .to({ x: target.position.x, y: target.position.y, z: target.position.z },
                        Math.random() * duration + duration)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();

                new TWEEN.Tween(object.rotation)
                    .to({ x: target.rotation.x, y: target.rotation.y, z: target.rotation.z },
                        Math.random() * duration + duration)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .start();
            }

            new TWEEN.Tween(this)
                .to({}, duration * 2)
                .onUpdate(render)
                .start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function generatePointsOnTriangle(A, B, C, count) {
            const points = [];
            const spacingFactor = 0.88; 

            if (count === 1) {
                points.push(A.clone().add(B).add(C).multiplyScalar(1/3)); // centroid
            } else {
                // minimal rows so that triangular number >= count
                let rows = 0;
                while ((rows + 1) * (rows + 2) / 2 < count) rows++;

                const centroid = A.clone().add(B).add(C).multiplyScalar(1/3);

                for (let i = 0; i <= rows; i++) {
                    for (let j = 0; j <= rows - i; j++) {
                        const u = i / rows;
                        const v = j / rows;
                        const w = 1 - u - v;
                        let pt = new THREE.Vector3()
                            .addScaledVector(A, u)
                            .addScaledVector(B, v)
                            .addScaledVector(C, w);

                        // push point slightly away from centroid
                        pt.sub(centroid).multiplyScalar(spacingFactor).add(centroid);

                        points.push(pt);
                    }
                }

                // sample exactly 'count' points
                const stride = Math.floor(points.length / count);
                const sampled = [];
                for (let k = 0; sampled.length < count && k < points.length; k += stride) {
                    sampled.push(points[k]);
                }
                return sampled;
            }
            return points;
        }

    </script>
</body>
</html>